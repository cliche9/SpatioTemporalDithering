#define DITHER_MODE_DISABLED 0
#define DITHER_MODE_PER_PIXEL_4X 1
#define DITHER_MODE_PER_PIXEL_16X 2
#define DITHER_MODE_PER_JITTER 3
#define DITHER_MODE_RUSSIAN_ROULETTE 4
#define DITHER_MODE_PERIODIC 5

#ifndef DITHER_MODE
#define DITHER_MODE DITHER_MODE_DISABLED
#endif

StructuredBuffer<uint> gStratifiedIndices;
StructuredBuffer<uint> gStratifiedLookUpTable;

static const int4x4 ditherMatrix = int4x4(
        float4(0, 8, 2, 10),
        float4(12, 4, 14, 6),
        float4(3, 11, 1, 9),
        float4(15, 7, 13, 5)
    );

float hash1D(float v)
{
    return frac(1.0e4 * sin(17.0 * v.x) * (0.1 + abs(sin(v.x))));
}

// Hash function from "Improved Alpha Testing Using Hashed Sampling"
float hash(float2 v)
{
    return frac(1.0e4 * sin(17.0 * v.x + 0.1 * v.y) * (0.1 + abs(sin(13.0 * v.y + v.x))));
}

// 3D hash function from "Improved Alpha Testing Using Hashed Sampling"
float hash3D(float3 v)
{
    return hash(float2(hash(v.xy), v.z));
}

// 4D hash function based on the 3D hash function
float hash4D(float4 v)
{
    return hash(float2(hash3D(v.xyz), v.w));
}

bool winRoulette(float alpha, uint frameIndex, float3 posW)
{
    // quantize posW
    posW = floor(posW * 1000.0) / 1000.0;
    float rng = hash4D(float4(posW, frameIndex));
    if(rng > alpha) return false;
    return true;
}

bool winRotation(uint2 pixel, float alpha, uint frameIndex)
{
    float rng = 0.0;
    //rng += hash(float2(pixel));
    //frameIndex = frameIndex % 2048;
    //rng += float((pixel.y % 4u) + 4u * (pixel.x % 4u)) / 16.0;
    rng += ditherMatrix[pixel.x % 4u][pixel.y % 4u] / 16.0;
    rng += hash(float2(InstanceID(), GeometryIndex()));
    //rng = hash4D(float4(pixel.x, pixel.y, InstanceID(), GeometryIndex()));

    return frac(rng + frameIndex * alpha) < alpha;
}

uint ZOrderCurveIndex(uint2 coord)
{
    // Spread the bits of the x and y coordinates
    uint x = coord.x;
    uint y = coord.y;

    x = (x | (x << 16)) & 0x0000FFFF;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 16)) & 0x0000FFFF;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    // Combine the interleaved bits of x and y
    return x | (y << 1);
}

bool isCovered(uint2 pixel, float alpha, uint sampleIndex, uint sampleCount, uint frameIndex, float3 posW)
{


    // offset sample index
    //sampleIndex += (pixel.y % 4u) + 4u * (pixel.x % 4u);
    sampleIndex += ditherMatrix[pixel.x % 4u][pixel.y % 4u];
    //sampleIndex += uint(hash(float2(pixel)) * 256);
    //sampleIndex += uint(hash(float2(pixel.x % 4u, pixel.y % 4u)) * sampleCount);
    //sampleIndex += ZOrderCurveIndex(pixel);
    sampleIndex = sampleIndex % sampleCount;

    float hashPixel = hash(float2(pixel));
    float rng = 0.5; // TODO should be a varying value
    //float rng = hash(float2(hashPixel, float(frameIndex/sampleCount)));
    //float rng = hash1D(float(frameIndex) / float(sampleCount));
    int R = int(floor(alpha * sampleCount + rng));
    if(R >= sampleCount) return true;
    //float rng2 = hash(float2(pixel));
    //float rng2 = hash4D(float4(hashPixel, InstanceID(), GeometryIndex(), PrimitiveIndex() / 2u));
    //float rng2 = hash3D(float3(InstanceID(), GeometryIndex(), PrimitiveIndex() / 2u));
    float rng2 = hash3D(float3(InstanceID(), GeometryIndex(), 0));
    //float rng2 = hash4D(float4(hash3D(posW), InstanceID(), GeometryIndex(), PrimitiveIndex() / 2u));
    //float rng2 = 0.5;
    int index = int(lerp(gStratifiedIndices[R], gStratifiedIndices[R + 1], rng2));
    uint mask = gStratifiedLookUpTable[index];
    // mask for 0.4 => 6 bits set
    //mask = 0x2929; // 6 bits set, as regular as possible => very constant
    //mask = 0x1515; // 6 bits, only on even numbers => very constant
    //mask = 0xC63; // 6 bits in pairs of two => slight flicker
    //mask = 0x3F; // first 6 bits only => very visible flicker
    //mask = UPS; // 6 bits set, same corner in halton sequence => visible flicker

    if(mask & (1u << sampleIndex)) return true;
    return false;
}

float getPixelDitherThreshold(uint2 pixel)
{
    // use random offset to ensure that each primitive uses a different mask
    uint randomOffset = uint(hash3D(float3(InstanceID(), GeometryIndex(), PrimitiveIndex() / 2u))*7919);
    pixel.x += randomOffset % 4u;
    pixel.y += randomOffset / 4u;

    #if DITHER_MODE == DITHER_MODE_PER_PIXEL_4X
    pixel = pixel % 2u;
    float2x2 ditherMatrix = float2x2(
        float2(0.0, 2.0),
        float2(3.0, 1.0)
    );
    return (ditherMatrix[pixel.y][pixel.x] + 0.5) / 4.0;
    #else // assume 16 x
    pixel = pixel % 4u;
    float4x4 ditherMatrix = float4x4(
        float4(0.0, 8.0, 2.0, 10.0),
        float4(12.0, 4.0, 14.0, 6.0),
        float4(3.0, 11.0, 1.0, 9.0),
        float4(15.0, 7.0, 13.0, 5.0)
    );
    return (ditherMatrix[pixel.y][pixel.x] + 0.5) / 16.0;
    #endif
}