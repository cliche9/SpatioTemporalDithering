#define DITHER_MODE_DISABLED 0
#define DITHER_MODE_PER_PIXEL_4X 1
#define DITHER_MODE_PER_PIXEL_16X 2
#define DITHER_MODE_PER_JITTER 3
#define DITHER_MODE_RUSSIAN_ROULETTE 4
#define DITHER_MODE_PERIODIC 5
#define DITHER_MODE_HASH_GRID 6
#define DITHER_MODE_FRACTAL_DITHERING 7
#define DITHER_PER_PIXEL_4X_ROULETTE 8
#define DITHER_PER_PIXEL_9X_ROULETTE 9

#ifndef DITHER_MODE
#define DITHER_MODE DITHER_MODE_DISABLED
#endif

#define COVERAGE_CORRECTION_DISABLED 0
#define COVERAGE_CORRECTION_DLSS 1

#ifndef COVERAGE_CORRECTION
#define COVERAGE_CORRECTION COVERAGE_CORRECTION_DISABLED
#endif

StructuredBuffer<uint> gStratifiedIndices;
StructuredBuffer<uint> gStratifiedLookUpTable;

Texture3D<float> gDitherTex;
Texture2D<float> gDitherRampTex; // converts opacity to threshold for the dither tex
SamplerState gDitherSampler;
Texture2D<float> gNoiseTex;
SamplerState gNoiseSampler;

StructuredBuffer<uint> gPermutations3x3; // permutations packed into 4 bytes

cbuffer DitherConstants
{
    float2 gNoiseScale; // inverse resolution for noise texture
    float gGridScale;
    int gRotatePattern;
    int gAddNoiseOnPattern;
};

static const int4x4 ditherMatrix = int4x4(
        float4(0, 8, 2, 10),
        float4(12, 4, 14, 6),
        float4(3, 11, 1, 9),
        float4(15, 7, 13, 5)
    );


uint3x3 get3x3Permutation(uint id)
{
    uint elementCount, stride;
    gPermutations3x3.GetDimensions(elementCount, stride);
    uint packed = gPermutations3x3[id % elementCount];
    uint3x3 m;
    uint sumValues = 0; // To track the sum of the extracted values

    // Extract the first 8 values (4 bits each)
    [unroll] for (int i = 0; i < 8; i++)
    {
        uint value = (packed >> (i * 4)) & 0xF;
        m[i / 3][i % 3] = value;
        sumValues += value;
    }

    // Compute the missing value using sum formula (0+1+2+3+4+5+6+7+8 = 36)
    m[2][2] = 36 - sumValues;

    return m;
}


uint4 get2x2Permutation(uint i) {
    // only pretty configurations (first two numbers form a diagonal)
    /*switch (i % 8u) {
        case 0:  return uint4(0, 2, 3, 1);
        case 1:  return uint4(0, 3, 2, 1);
        case 2:  return uint4(2, 0, 1, 3);
        case 3:  return uint4(3, 0, 1, 2);
        case 4:  return uint4(2, 1, 0, 3);
        case 5:  return uint4(3, 1, 0, 2);
        case 6:  return uint4(1, 2, 3, 0);
        case 7:  return uint4(1, 3, 2, 0);
        default: return 0u;
    }*/
    switch (i % 24u) {
        case 0:  return uint4(0, 1, 2, 3);
        case 1:  return uint4(0, 1, 3, 2);
        case 2:  return uint4(0, 2, 1, 3);
        case 3:  return uint4(0, 2, 3, 1);
        case 4:  return uint4(0, 3, 1, 2);
        case 5:  return uint4(0, 3, 2, 1);
        case 6:  return uint4(1, 0, 2, 3);
        case 7:  return uint4(1, 0, 3, 2);
        case 8:  return uint4(1, 2, 0, 3);
        case 9:  return uint4(1, 2, 3, 0);
        case 10: return uint4(1, 3, 0, 2);
        case 11: return uint4(1, 3, 2, 0);
        case 12: return uint4(2, 0, 1, 3);
        case 13: return uint4(2, 0, 3, 1);
        case 14: return uint4(2, 1, 0, 3);
        case 15: return uint4(2, 1, 3, 0);
        case 16: return uint4(2, 3, 0, 1);
        case 17: return uint4(2, 3, 1, 0);
        case 18: return uint4(3, 0, 1, 2);
        case 19: return uint4(3, 0, 2, 1);
        case 20: return uint4(3, 1, 0, 2);
        case 21: return uint4(3, 1, 2, 0);
        case 22: return uint4(3, 2, 0, 1);
        case 23: return uint4(3, 2, 1, 0);
        default: return 0u;
    }
}


float hash1D(float v)
{
    return frac(1.0e4 * sin(17.0 * v.x) * (0.1 + abs(sin(v.x))));
}

// Hash function from "Improved Alpha Testing Using Hashed Sampling"
float hash(float2 v)
{
    return frac(1.0e4 * sin(17.0 * v.x + 0.1 * v.y) * (0.1 + abs(sin(13.0 * v.y + v.x))));
}

float noise(float2 uv)
{
    //return pow(gNoiseTex.SampleLevel(gNoiseSampler, uv * gNoiseScale, 0.0).r, 2.2);
    return gNoiseTex.SampleLevel(gNoiseSampler, uv * gNoiseScale, 0.0).r;
}

// 3D hash function from "Improved Alpha Testing Using Hashed Sampling"
float hash3D(float3 v)
{
    return hash(float2(hash(v.xy), v.z));
}

// 4D hash function based on the 3D hash function
float hash4D(float4 v)
{
    return hash(float2(hash3D(v.xyz), v.w));
}

int imod4(int v)
{
    return (v % 4 + 4) % 4;
}

float hashDither(float2 v)
{
    int x = imod4(int(v.x));
    int y = imod4(int(v.y));
    return (ditherMatrix[x][y] + 0.5) / 16.0;
}

bool winFractalDither(float opacity, float2 coord, float2 dx, float2 dy, float4x4 cameraProjection, uint frameCount)
{
    float g_Scale = gGridScale;
    float g_SizeVariability = 1.0;
    bool g_InvertPattern = true; // false: holes are round, true: occluders are round

    // adjusted dither code from: https://github.com/runevision/Dither3D/blob/main/Assets/Dither3D/Dither3DInclude.cginc
    float xRes, yRes, zRes;
    gDitherTex.GetDimensions(xRes, yRes, zRes);
    float invXres = 1.0 / xRes; // yRes should be same
    
    // The relationship between X resolution, dots per side, and total number of
    // dots - which is also the Z resolution - is hardcoded in the script that
    // creates the 3D texture.
    float dotsPerSide = xRes / 16.0;
    float dotsTotal = zRes; // or pow(dotsPerSide, 2);
    float invZres = 1.0 / zRes;

    // Lookup opacity to make dither output have correct output
    // opacity at different input opacity values.
    float xRamp, yRamp;
    gDitherRampTex.GetDimensions(xRamp, yRamp);
    if(g_InvertPattern) opacity = 1.0 - opacity;
    float lookup = lerp(0.5, xRamp - 0.5, opacity) / xRamp; // adjust opacity lookup position
    opacity = gDitherRampTex.SampleLevel(gDitherSampler, float2(lookup, 0.5), 0.0);

    #define RADIAL_COMPENSATION 0
    #if RADIAL_COMPENSATION != 0
    // Convert pixel coordinate to normalized screen space [-1, 1] with (0, 0) at the center
    float2 screenP = (float2(DispatchRaysIndex().xy) / float2(DispatchRaysDimensions().xy) - 0.5) * 2.0;
    // Calculate view direction projected onto camera plane.
    float2 viewDirProj = float2(
        screenP.x / cameraProjection[0][0],
        screenP.y / -cameraProjection[1][1]
    );

    // Calculate how much dots should be larger towards the edges of the screen.
    // This is meant to keep dots completely stable under camera rotation.
    // Currently it doesn't entirely work but is more stable than no compensation.
    float radialCompensation = dot(viewDirProj, viewDirProj) + 1;

    // Apply compensation to dx and dy
    dx *= radialCompensation;
    dy *= radialCompensation;
    #endif
    
    // Get frequency based on singular value decomposition.
    // A simpler approach would have been to use fwidth(uv_DitherTex).
    // However:
    //  1) fwidth is not accurate and produces axis-aligned biases/artefacts.
    //  2) We need both the minimum and maximum rate of change.
    //     These can be along any directions (orthogonal to each other),
    //     not necessarily aligned with x, y, u or v.
    //     So we use (a subset of) singular value decomposition to get these.
    float2x2 matr = { dx, dy };
    float4 vectorized = float4(dx, dy);
    float Q = dot(vectorized, vectorized);
    float R = determinant(matr); //ad-bc
    float discriminantSqr = max(0, Q*Q-4*R*R);
    float discriminant = sqrt(discriminantSqr);

    // "freq" here means rate of change of the UV coordinates on the screen.
    // Something smaller on the screen has a larger rate of change of its
    // UV coordinates from one pixel to the next.
    //
    // The freq variable: (max-freq, min-freq)
    //
    // If a surface has non-uniform scaling, or is seen at an angle,
    // or has UVs that are stretched more in one direction than the other,
    // the min and max frequency won't be the same.
    float2 freq = sqrt(float2(Q + discriminant, Q - discriminant) / 2);

    // We define a spacing variable which linearly correlates with
    // the average distance between dots.
    // For this dot spacing, we use the smaller frequency, which
    // corresponds to the largest amount of stretching.
    // This for example means that dots seen at an angle will be
    // compressed in one direction rather than enlarged in the other.
    float spacing = freq.y;

    // Scale the spacing by the specified input (power of two) scale.
    float scaleExp = exp2(g_Scale);
    spacing *= scaleExp;

    // We keep the spacing the same regardless of whether we're using
    // a pattern with more or less dots in it.
    spacing *= dotsPerSide * 0.125;

    // We produce higher brightness by having the dots be larger
    // compared to the pattern size (based on a contrast threshold
    // further down), and lower brightness by having them be smaller.
    //
    // If we don't want variable dot sizes, we can keep the dot sizes
    // approximately constant regardless of brightness by dividing
    // the spacing by the brightness. This makes both the dots and
    // the spacing between them larger, the lower the brightness is.
    // In this case, the two adjustments of dot size cancel out each
    // other, leaving only the effect on the spacing between the dots.
    //
    // Any behavior in between these two is also possible, controlled by
    // the _SizeVariability input.
    //
    // A*pow(B,-1) is the same as A/B, so when _SizeVariability is 0,
    // we divide the spacing by the brightness.
    //
    // A*pow(B,0) is the same as A, so when _SizeVariability is 1,
    // we leave the spacing alone.
    //
    // The "* 2" is there so the mid-size dots keeps constant throughout
    // the spectrum, rather than the largest-sized dots.
    // The "+ 0.001" is there to avoid dividing by zero.
    float brightnessSpacingMultiplier =
        pow(opacity * 2 + 0.001, -(1 - g_SizeVariability));
    spacing *= brightnessSpacingMultiplier;

    // Find the power-of-two level that corresponds to the dot spacing.
    float spacingLog = log2(spacing);
    int patternScaleLevel = floor(spacingLog); // Fractal level.
    float f = spacingLog - patternScaleLevel; // Fractional part.

    // Get the UV coordinates in the current fractal level.
    float2 uv = coord / exp2(patternScaleLevel);

    // Get the third coordinate for the 3D texture lookup.
    // Each layer along the 3rd dimension in the 3D texture has one more dot.
    // The first layer we use is the one that has 1/4 of the dots.
    // The last layer we use is the one with all the dots.
    float subLayer = lerp(0.25 * dotsTotal, dotsTotal, 1 - f);

    // Texels are half a texel offset from the texture border, so we
    // need to subtract half a texel. We also normalize to the 0-1 range.
    subLayer = (subLayer - 0.5) * invZres;

    // Sample the 3D texture.
    //float pattern = 1.0 - gDitherTex.SampleLevel(gDitherSampler, float3(uv, 1.0-subLayer), 0.0).r;
    float pattern = gDitherTex.SampleLevel(gDitherSampler, float3(uv, 1.0-subLayer), 0.0).r;

    //float extraRng = hash3D(float3(coord, frameCount));
    //pattern += (extraRng - 0.5);
    //pattern = frac(pattern);

    if(g_InvertPattern) return pattern > opacity;
    else return pattern < opacity;
}

bool winHashGrid2D(float opacity, float2 coord, float maxDeriv, uint2 pixel, uint frameCount)
{
    // from Hashed Alpha Testing
    //float g_HashScale = 1.0;
    float g_HashScale = gGridScale; // subpixel scale (expect ~4*4 = 16 subpixels)

    float pixScale = 1.0 / (g_HashScale * maxDeriv);

    // version without LOD
    //pixScale = ceil(pixScale);
    //float threshold = hash((pixScale * coord));

    
    // Find two nearest log-discretized noise scales
    float2 pixScales = float2(
        exp2(floor(log2(pixScale))),
        exp2(ceil(log2(pixScale))) 
        //floor(pixScale),
        //ceil(pixScale) 
    );

    uint2 offset = 0;
    //offset.x = frameCount % 2u;
    //offset.y = (frameCount / 2u) % 2u;

    // Compute alpha thresholds at our two noise scales
    float2 alpha = float2(
        //hash(floor(pixScales.x * coord)),
        //hash(floor(pixScales.y * coord))
        noise(floor(pixScales.x * coord) + float2(offset)),
        noise(floor(pixScales.y * coord) + float2(offset))
    );
    alpha = 1.0 - alpha;

    int4 hashPixel = int4(floor(pixScales.x * coord), floor(pixScales.y * coord));
    //int2 stratIndex = int2(ditherMatrix[imod4(hashPixel.x)][imod4(hashPixel.y)], ditherMatrix[imod4(hashPixel.z)][imod4(hashPixel.w)]);
    //int stratIndex = ditherMatrix[imod4(hashPixel.x)][imod4(hashPixel.y)];
    //int stratIndex = (ditherMatrix[pixel.x % 4][pixel.y % 4] + frameCount) % 16;
    //int stratIndex = ((pixel.x % 4) + 4 * (pixel.y % 4) + frameCount) % 16;
    // augment alpha for stratified index
    //alpha = (alpha + float2(stratIndex)) / 16.0;

    // Factor to interpolate lerp with
    float lerpFactor = frac( log2(pixScale) );
    //lerpFactor = 1.0;
    //float lerpFactor = frac( pixScale );
    
    // Interpolate alpha threshold from noise at two scales
    float x = (1.0 - lerpFactor) * alpha.x + lerpFactor * alpha.y;
    
    // Pass into CDF to compute uniformly distrib threshold
    float a = min(lerpFactor, 1.0 - lerpFactor);
    float3 cases = float3( 
        x * x / (2 * a * (1.0 - a)),
        (x - 0.5 * a) / (1.0 - a),
        1.0 - ((1.0 - x) * (1.0 - x)/(2.0 * a * (1.0 - a)))
    );

    float threshold = (x < (1-a)) ? ((x < a) ? cases.x : cases.y) : cases.z;

    // stratify here
    //float rng1 = hash3D(float3(GeometryIndex(), PrimitiveIndex() / 2u, InstanceID()));//threshold;//(ditherMatrix[imod4(hashPixel.x)][imod4(hashPixel.y)]) / 16.0;
    //float rng2 = hash3D(float3(InstanceID(), GeometryIndex(), PrimitiveIndex() / 2u));
    //int i = frameCount % 16;
    //i = ((pixel.x % 4) + 4 * (pixel.y % 4) + frameCount) % 16;
    //int a0 = int(16 * rng1);
    //int aplus = 2 * int(0.5 * 16.0 * rng2) + 1;
    //threshold = (threshold + float((a0 + i * aplus) % 16)) / 16.0;

    


    threshold = clamp(threshold, 1e-6, 1.0);
    


    return opacity >= threshold;
}

bool winHashGrid(float opacity, float3 coord, float maxDeriv)
{
    // from Hashed Alpha Testing
    //float g_HashScale = 1.0;
    float g_HashScale = gGridScale; // subpixel scale (expect ~4*4 = 16 subpixels)

    float pixScale = 1.0 / (g_HashScale * maxDeriv);

    // Find two nearest log-discretized noise scales
    float2 pixScales = float2(
        exp2(floor(log2(pixScale))),
        exp2(ceil(log2(pixScale))) 
    );

    // Compute alpha thresholds at our two noise scales
    float2 alpha = float2(
        hash3D(floor(pixScales.x * coord)),
        hash3D(floor(pixScales.y * coord))
    );

    // Factor to interpolate lerp with
    float lerpFactor = frac( log2(pixScale) );
    
    // Interpolate alpha threshold from noise at two scales
    float x = (1.0 - lerpFactor) * alpha.x + lerpFactor * alpha.y;
    
    // Pass into CDF to compute uniformly distrib threshold
    float a = min(lerpFactor, 1.0 - lerpFactor);
    float3 cases = float3( 
        x * x / (2 * a * (1.0 - a)),
        (x - 0.5 * a) / (1.0 - a),
        1.0 - ((1.0 - x) * (1.0 - x)/(2.0 * a * (1.0 - a)))
    );

    float threshold = (x < (1-a)) ? ((x < a) ? cases.x : cases.y) : cases.z;
    threshold = clamp(threshold, 1e-6, 1.0);
    
    return opacity >= threshold;
}

bool winRoulette(float alpha, uint frameIndex, float3 posW)
{
    // quantize posW
    //posW = floor(posW * 1000.0) / 1000.0;
    float rng = hash4D(float4(posW, frameIndex));
    if(rng > alpha) return false;
    return true;
}

bool winRotation(uint2 pixel, float alpha, uint frameIndex)
{
    // quantize alpha?
    //alpha = floor(alpha * 16.0) / 16.0;

    float rng = 0.0;
    //rng += hash(float2(pixel));
    //frameIndex = frameIndex % 2048;
    //rng += float((pixel.x % 4u) + 4u * (pixel.y % 4u)) / 16.0;
    rng += ditherMatrix[pixel.x % 4u][pixel.y % 4u] / 16.0;
    rng += hash(float2(InstanceID(), GeometryIndex()));
    //rng = hash4D(float4(pixel.x, pixel.y, InstanceID(), GeometryIndex()));

    return frac(rng + frameIndex * alpha) < alpha;
}

uint ZOrderCurveIndex(uint2 coord)
{
    // Spread the bits of the x and y coordinates
    uint x = coord.x;
    uint y = coord.y;

    x = (x | (x << 16)) & 0x0000FFFF;
    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 16)) & 0x0000FFFF;
    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    // Combine the interleaved bits of x and y
    return x | (y << 1);
}

bool isCovered(uint2 pixel, float alpha, uint sampleIndex, uint sampleCount, uint frameIndex, float3 posW)
{


    // offset sample index
    //sampleIndex += (pixel.y % 4u) + 4u * (pixel.x % 4u);
    sampleIndex += ditherMatrix[pixel.x % 4u][pixel.y % 4u];
    //sampleIndex += uint(hash(float2(pixel)) * 256);
    //sampleIndex += uint(hash(float2(pixel.x % 4u, pixel.y % 4u)) * sampleCount);
    //sampleIndex += ZOrderCurveIndex(pixel);
    sampleIndex = sampleIndex % sampleCount;

    float hashPixel = hash(float2(pixel));
    float rng = 0.5; // TODO should be a varying value
    //float rng = hash(float2(hashPixel, float(frameIndex/sampleCount)));
    //rng = hash1D(float(frameIndex) / float(sampleCount));
    int R = int(floor(alpha * sampleCount + rng));
    if(R >= sampleCount) return true;
    //float rng2 = hash(float2(pixel));
    //float rng2 = hash4D(float4(hashPixel, InstanceID(), GeometryIndex(), PrimitiveIndex() / 2u));
    //float rng2 = hash3D(float3(InstanceID(), GeometryIndex(), PrimitiveIndex() / 2u));
    float rng2 = hash3D(float3(InstanceID(), GeometryIndex(), 0));
    //float rng2 = hash4D(float4(hash3D(posW), InstanceID(), GeometryIndex(), PrimitiveIndex() / 2u));
    //float rng2 = 0.5;
    int index = int(lerp(gStratifiedIndices[R], gStratifiedIndices[R + 1], rng2));
    uint mask = gStratifiedLookUpTable[index];
    // mask for 0.4 => 6 bits set
    //mask = 0x2929; // 6 bits set, as regular as possible => very constant
    //mask = 0x1515; // 6 bits, only on even numbers => very constant
    //mask = 0xC63; // 6 bits in pairs of two => slight flicker
    //mask = 0x3F; // first 6 bits only => very visible flicker
    //mask = UPS; // 6 bits set, same corner in halton sequence => visible flicker

    if(mask & (1u << sampleIndex)) return true;
    return false;
}

// Helper function to extract bits at even positions for x or odd positions for y
uint CompactBits(uint n) {
    // Masks and shifts to compact bits from a Morton code
    n &= 0x55555555;              // Mask: 0b01010101...
    n = (n ^ (n >> 1)) & 0x33333333;  // Mask and compact pairs
    n = (n ^ (n >> 2)) & 0x0F0F0F0F;  // Compact nibbles
    n = (n ^ (n >> 4)) & 0x00FF00FF;  // Compact bytes
    n = (n ^ (n >> 8)) & 0x0000FFFF;  // Compact words
    return n;
}

// Converts a Morton code uint into a uint2 (x, y) position along the Z-order curve
uint2 DecodeMorton2D(uint morton) {
    uint x = CompactBits(morton);           // Extract even bits for x
    uint y = CompactBits(morton >> 1);      // Extract odd bits for y
    return uint2(x, y);
}


float getPixelDitherThreshold(uint2 pixel, uint objectOffet, float3 posW, uint frameIndex)
{
    uint randomOffset = uint(hash3D(float3(InstanceID(), GeometryIndex(), HitKind() == HIT_KIND_TRIANGLE_FRONT_FACE)) * 7919);
    //if (objectOffset <= 4) randomOffset = objectOffset;

    // use random offset to ensure that each primitive uses a different mask
    #if DITHER_MODE == DITHER_MODE_PER_PIXEL_4X
    if(gRotatePattern) randomOffset += frameIndex; // rotate lookup based on frame index
    pixel.x += randomOffset % 2u;
    pixel.y += randomOffset / 2u;
    pixel = pixel % 2u;
    float2x2 ditherMatrix = float2x2(
        float2(0.0, 2.0),
        float2(3.0, 1.0)
    );
    float divisor = 4.0;
    float ditherThreshold = ditherMatrix[pixel.y][pixel.x];
    #else // assume 16 x
    if(gRotatePattern) randomOffset += frameIndex; // rotate lookup based on frame index
    //if(gRotatePattern) pixel += DecodeMorton2D(frameIndex);
    pixel.x += randomOffset % 4u;
    pixel.y += randomOffset / 4u;
    pixel = pixel % 4u;
    float4x4 ditherMatrix = float4x4(
        float4(0.0, 8.0, 2.0, 10.0),
        float4(12.0, 4.0, 14.0, 6.0),
        float4(3.0, 11.0, 1.0, 9.0),
        float4(15.0, 7.0, 13.0, 5.0)
    );
    float divisor = 16.0;
    float ditherThreshold = ditherMatrix[pixel.y][pixel.x];
    #endif

    if(gAddNoiseOnPattern) 
    {
        ditherThreshold += hash4D(float4(posW, frameIndex));
    } 
    else ditherThreshold += 0.5;

    return ditherThreshold / divisor;
}

float getPixelDitherThresholdPlusRoulette(uint2 pixel, uint frameIndex, float3 posW, uint objectOffset)
{
    // use random offset to ensure that each primitive uses a different mask
    //uint randomOffset = uint(hash3D(float3(InstanceID(), GeometryIndex(), PrimitiveIndex() / 2u)) * 7919);
    uint randomOffset = uint(hash3D(float3(InstanceID(), GeometryIndex(), HitKind() == HIT_KIND_TRIANGLE_FRONT_FACE)) * 7919);
    //if (objectOffset <= 4) randomOffset = objectOffset;

    uint4 mask = get2x2Permutation(randomOffset); // mask with [0, 1, 2, 3] permutation
    uint lookup = (pixel.x % 2u) + 2u * (pixel.y % 2u);
    if(gRotatePattern) lookup = (lookup + frameIndex) % 4u; // rotate lookup based on frame index
    uint v = mask[lookup]; // 0, 1, 2 or 3
    
    float ditherThreshold = v / 4.0;
    if(gAddNoiseOnPattern) 
    {
        ditherThreshold += hash4D(float4(posW, frameIndex)) * 0.25;
        //ditherThreshold += ((frameIndex * odds[oddPixel.x][oddPixel.y]) % 8u) / 8.0 * 0.25;
    } 
    else ditherThreshold += 0.125;
    
    return ditherThreshold;
}

float getPixelDitherThresholdPlusRoulette3x3(uint2 pixel, uint frameIndex, float3 posW, uint objectOffset)
{
    // use random offset to ensure that each primitive uses a different mask
    uint randomOffset = uint(hash3D(float3(InstanceID(), GeometryIndex(), HitKind() == HIT_KIND_TRIANGLE_FRONT_FACE)) * 7919);
    if(gRotatePattern)
    {
        pixel.x += frameIndex % 3;
        pixel.y += frameIndex / 3;
    }
    //if(gRotatePattern) randomOffset += frameIndex; // rotate lookup based on frame index
    //pixel.x += randomOffset % 3u;
    //pixel.y += randomOffset / 3u;
    pixel = pixel % 3u;

    //uint3x3 mask = uint3x3(uint3(0, 7, 3), uint3(6, 5, 2), uint3(4, 1, 8));
    uint3x3 mask = get3x3Permutation(randomOffset);
    uint v = mask[pixel.y][pixel.x]; // 0-8
    
    float ditherThreshold = v / 9.0;
    if(gAddNoiseOnPattern) 
    {
        ditherThreshold += hash4D(float4(posW, frameIndex)) / 9.0;
    } 
    else ditherThreshold += 1.0 / 18.0;
    
    return ditherThreshold;
}
